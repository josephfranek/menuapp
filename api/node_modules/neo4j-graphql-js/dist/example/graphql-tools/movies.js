'use strict';

var _graphqlTools = require('graphql-tools');

var _index = require('../../src/index');

var _express = require('express');

var _express2 = _interopRequireDefault(_express);

var _apolloServerExpress = require('apollo-server-express');

var _bodyParser = require('body-parser');

var _bodyParser2 = _interopRequireDefault(_bodyParser);

var _neo4jDriver = require('neo4j-driver');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Simple Movie schema
var typeDefs = '\ntype Movie {\n  movieId: ID!\n  title: String\n  year: Int\n  plot: String\n  poster: String\n  imdbRating: Float\n  genres: [Genre] @relation(name: "IN_GENRE", direction: "OUT")\n  similar(first: Int = 3, offset: Int = 0, limit: Int = 5): [Movie] @cypher(statement: "WITH {this} AS this MATCH (this)--(:Genre)--(o:Movie) RETURN o LIMIT {limit}")\n  mostSimilar: Movie @cypher(statement: "WITH {this} AS this RETURN this")\n  degree: Int @cypher(statement: "WITH {this} AS this RETURN SIZE((this)--())")\n  actors(first: Int = 3, offset: Int = 0): [Actor] @relation(name: "ACTED_IN", direction:"IN")\n  avgStars: Float\n  filmedIn: State @relation(name: "FILMED_IN", direction: "OUT")\n  scaleRating(scale: Int = 3): Float @cypher(statement: "WITH $this AS this RETURN $scale * this.imdbRating")\n  scaleRatingFloat(scale: Float = 1.5): Float @cypher(statement: "WITH $this AS this RETURN $scale * this.imdbRating")\n}\n\ntype Genre {\n  name: String\n  movies(first: Int = 3, offset: Int = 0): [Movie] @relation(name: "IN_GENRE", direction: "IN")\n  highestRatedMovie: Movie @cypher(statement: "MATCH (m:Movie)-[:IN_GENRE]->(this) RETURN m ORDER BY m.imdbRating DESC LIMIT 1")\n}\n\ntype State {\n  name: String\n}\n\ninterface Person {\n\tid: ID!\n  name: String\n}\n\ntype Actor {\n  id: ID!\n  name: String\n  movies: [Movie] @relation(name: "ACTED_IN", direction: "OUT")\n}\n\ntype User implements Person {\n  id: ID!\n\tname: String\n}\n\nenum BookGenre {\n  Mystery,\n  Science,\n  Math\n}\n\ntype Book {\n  genre: BookGenre\n}\n\ntype Query {\n  Movie(id: ID, title: String, year: Int, plot: String, poster: String, imdbRating: Float, first: Int, offset: Int): [Movie]\n  MoviesByYear(year: Int): [Movie]\n  AllMovies: [Movie]\n  MovieById(movieId: ID!): Movie\n  GenresBySubstring(substring: String): [Genre] @cypher(statement: "MATCH (g:Genre) WHERE toLower(g.name) CONTAINS toLower($substring) RETURN g")\n  Books: [Book]\n}';

var resolvers = {
  // root entry point to GraphQL service
  Query: {
    // fetch movies by title substring
    Movie: function Movie(object, params, ctx, resolveInfo) {
      return (0, _index.neo4jgraphql)(object, params, ctx, resolveInfo, true);
    },
    MoviesByYear: function MoviesByYear(object, params, ctx, resolveInfo) {
      return (0, _index.neo4jgraphql)(object, params, ctx, resolveInfo, true);
    },
    AllMovies: function AllMovies(object, params, ctx, resolveInfo) {
      return (0, _index.neo4jgraphql)(object, params, ctx, resolveInfo, true);
    },
    MovieById: function MovieById(object, params, ctx, resolveInfo) {
      return (0, _index.neo4jgraphql)(object, params, ctx, resolveInfo, true);
    },
    GenresBySubstring: function GenresBySubstring(object, params, ctx, resolveInfo) {
      return (0, _index.neo4jgraphql)(object, params, ctx, resolveInfo, true);
    },
    Books: function Books(object, params, ctx, resolveInfo) {
      return (0, _index.neo4jgraphql)(object, params, ctx, resolveInfo, true);
    }
  }
};

// Mutation: {
//   CreateGenre(object, params, ctx, resolveInfo) {
//     return neo4jgraphql(object, params, ctx, resolveInfo, true);
//   },
//   CreateMovie(object, params, ctx, resolveInfo) {
//     return neo4jgraphql(object, params, ctx, resolveInfo, true);
//   },
//   AddMovieGenre(object, params, ctx, resolveInfo) {
//     return neo4jgraphql(object, params, ctx, resolveInfo, true);
//   }
// }

var schema = (0, _graphqlTools.makeExecutableSchema)({
  typeDefs: typeDefs,
  resolvers: resolvers,
  resolverValidationOptions: {
    requireResolversForResolveType: false
  }
});

// Add auto-generated mutations
var augmentedSchema = (0, _index.augmentSchema)(schema);

var driver = void 0;

function context(headers, secrets) {
  if (!driver) {
    driver = _neo4jDriver.v1.driver(secrets.NEO4J_URI || 'bolt://localhost:7687', _neo4jDriver.v1.auth.basic(secrets.NEO4J_USER || 'neo4j', secrets.NEO4J_PASSWORD || 'letmein'));
  }
  return {
    driver: driver,
    headers: headers
  };
}

var rootValue = {};

var PORT = 3000;
var server = (0, _express2.default)();

server.use('/graphql', _bodyParser2.default.json(), (0, _apolloServerExpress.graphqlExpress)(function (request) {
  return {
    schema: augmentedSchema,
    rootValue: rootValue,
    context: context(request.headers, process.env)
  };
}));

server.use('/graphiql', (0, _apolloServerExpress.graphiqlExpress)({
  endpointURL: '/graphql',
  query: '{\n  \n}'
}));

server.listen(PORT, function () {
  console.log('GraphQL Server is now running on http://localhost:' + PORT + '/graphql');
  console.log('View GraphiQL at http://localhost:' + PORT + '/graphiql');
});
//# sourceMappingURL=movies.js.map