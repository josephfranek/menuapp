'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.relationDirective = exports.cypherDirective = undefined;

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

exports.parseArgs = parseArgs;
exports.cypherDirectiveArgs = cypherDirectiveArgs;
exports.isMutation = isMutation;
exports.isAddRelationshipMutation = isAddRelationshipMutation;
exports.typeIdentifiers = typeIdentifiers;
exports.isGraphqlScalarType = isGraphqlScalarType;
exports.isArrayType = isArrayType;
exports.lowFirstLetter = lowFirstLetter;
exports.innerType = innerType;
exports.innerFilterParams = innerFilterParams;
exports.extractQueryResult = extractQueryResult;
exports.computeSkipLimit = computeSkipLimit;
exports.extractSelections = extractSelections;
exports.fixParamsForAddRelationshipMutation = fixParamsForAddRelationshipMutation;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parseArgs(args, variableValues) {
  // get args from selection.arguments object
  // or from resolveInfo.variableValues if arg is a variable
  // note that variable values override default values

  if (!args) {
    return {};
  }

  if (args.length === 0) {
    return {};
  }

  return args.reduce(function (acc, arg) {
    switch (arg.value.kind) {
      case 'IntValue':
        acc[arg.name.value] = parseInt(arg.value.value);
        break;
      case 'FloatValue':
        acc[arg.name.value] = parseFloat(arg.value.value);
        break;
      case 'Variable':
        acc[arg.name.value] = variableValues[arg.name.value];
        break;
      default:
        acc[arg.name.value] = arg.value.value;
    }

    return acc;
  }, {});
}

function getDefaultArguments(fieldName, schemaType) {
  // get default arguments for this field from schema

  try {
    return schemaType._fields[fieldName].args.reduce(function (acc, arg) {
      acc[arg.name] = arg.defaultValue;
      return acc;
    }, {});
  } catch (err) {
    return {};
  }
}

function cypherDirectiveArgs(variable, headSelection, schemaType, resolveInfo) {
  var defaultArgs = getDefaultArguments(headSelection.name.value, schemaType);
  var queryArgs = parseArgs(headSelection.arguments, resolveInfo.variableValues);

  var args = (0, _stringify2.default)((0, _assign2.default)(defaultArgs, queryArgs)).replace(/\"([^(\")"]+)\":/g, ' $1: ');

  return args === '{}' ? '{this: ' + variable + args.substring(1) : '{this: ' + variable + ',' + args.substring(1);
}

function isMutation(resolveInfo) {
  return resolveInfo.operation.operation === 'mutation';
}

function isAddRelationshipMutation(resolveInfo) {
  return resolveInfo.operation.operation === 'mutation' && (resolveInfo.fieldName.startsWith('Add') || resolveInfo.fieldName.startsWith('add')) && resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.directives.filter(function (x) {
    return x.name.value === 'MutationMeta';
  }).length > 0;
}

function typeIdentifiers(returnType) {
  var typeName = innerType(returnType).toString();
  return {
    variableName: lowFirstLetter(typeName),
    typeName: typeName
  };
}

function isGraphqlScalarType(type) {
  return type.constructor.name === 'GraphQLScalarType' || type.constructor.name === 'GraphQLEnumType';
}

function isArrayType(type) {
  return type.toString().startsWith('[');
}

function lowFirstLetter(word) {
  return word.charAt(0).toLowerCase() + word.slice(1);
}

function innerType(type) {
  return type.ofType ? innerType(type.ofType) : type;
}

// handles field level schema directives
// TODO: refactor to handle Query/Mutation type schema directives
var directiveWithArgs = function directiveWithArgs(directiveName, args) {
  return function (schemaType, fieldName) {
    function fieldDirective(schemaType, fieldName, directiveName) {
      return schemaType.getFields()[fieldName].astNode.directives.find(function (e) {
        return e.name.value === directiveName;
      });
    }

    function directiveArgument(directive, name) {
      return directive.arguments.find(function (e) {
        return e.name.value === name;
      }).value.value;
    }

    var directive = fieldDirective(schemaType, fieldName, directiveName);
    var ret = {};
    if (directive) {
      _assign2.default.apply(Object, [ret].concat((0, _toConsumableArray3.default)(args.map(function (key) {
        return (0, _defineProperty3.default)({}, key, directiveArgument(directive, key));
      }))));
    }
    return ret;
  };
};

var cypherDirective = exports.cypherDirective = directiveWithArgs('cypher', ['statement']);
var relationDirective = exports.relationDirective = directiveWithArgs('relation', ['name', 'direction']);

function innerFilterParams(selections) {
  var queryParams = '';

  if (selections && selections.length && selections[0].arguments && selections[0].arguments.length) {
    var filters = selections[0].arguments.filter(function (x) {
      return x.name.value !== 'first' && x.name.value !== 'offset';
    }).map(function (x) {
      var filterValue = (0, _stringify2.default)(x.value.value).replace(/\"([^(\")"]+)\":/g, '$1:'); // FIXME: support IN for multiple values -> WHERE
      return x.name.value + ': ' + filterValue;
    });

    queryParams = '{' + filters.join(',') + '}';
  }
  return queryParams;
}

function argumentValue(selection, name, variableValues) {
  var arg = selection.arguments.find(function (a) {
    return a.name.value === name;
  });
  if (!arg) {
    return null;
  } else if (!arg.value.value && name in variableValues && arg.value.kind === 'Variable') {
    return variableValues[name];
  } else {
    return arg.value.value;
  }
}

function extractQueryResult(_ref2, returnType) {
  var records = _ref2.records;

  var _typeIdentifiers = typeIdentifiers(returnType),
      variableName = _typeIdentifiers.variableName;

  return isArrayType(returnType) ? records.map(function (record) {
    return record.get(variableName);
  }) : records.length ? records[0].get(variableName) : null;
}

function computeSkipLimit(selection, variableValues) {
  var first = argumentValue(selection, 'first', variableValues);
  var offset = argumentValue(selection, 'offset', variableValues);

  if (first === null && offset === null) return '';
  if (offset === null) return '[..' + first + ']';
  if (first === null) return '[' + offset + '..]';
  return '[' + offset + '..' + (parseInt(offset) + parseInt(first)) + ']';
}

function extractSelections(selections, fragments) {
  // extract any fragment selection sets into a single array of selections
  return selections.reduce(function (acc, cur) {
    if (cur.kind === 'FragmentSpread') {
      return [].concat((0, _toConsumableArray3.default)(acc), (0, _toConsumableArray3.default)(fragments[cur.name.value].selectionSet.selections));
    } else {
      return [].concat((0, _toConsumableArray3.default)(acc), [cur]);
    }
  }, []);
}

function fixParamsForAddRelationshipMutation(params, resolveInfo) {
  // FIXME: find a better way to map param name in schema to datamodel
  var mutationMeta = void 0,
      fromTypeArg = void 0,
      toTypeArg = void 0;

  try {
    mutationMeta = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.directives.filter(function (x) {
      return x.name.value === 'MutationMeta';
    })[0];
  } catch (e) {
    throw new Error('Missing required MutationMeta directive on add relationship directive');
  }

  try {
    fromTypeArg = mutationMeta.arguments.filter(function (x) {
      return x.name.value === 'from';
    })[0];

    toTypeArg = mutationMeta.arguments.filter(function (x) {
      return x.name.value === 'to';
    })[0];
  } catch (e) {
    throw new Error('Missing required argument in MutationMeta directive (relationship, from, or to)');
  }
  //TODO: need to handle one-to-one and one-to-many

  var fromType = fromTypeArg.value.value,
      toType = toTypeArg.value.value,
      fromVar = lowFirstLetter(fromType),
      toVar = lowFirstLetter(toType),
      fromParam = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.arguments[0].name.value.substr(fromVar.length),
      toParam = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.arguments[1].name.value.substr(toVar.length);

  params[toParam] = params[resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.arguments[1].name.value];

  params[fromParam] = params[resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.arguments[0].name.value];

  delete params[resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.arguments[1].name.value];

  delete params[resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.arguments[0].name.value];

  console.log(params);

  return params;
}