'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.neo4jgraphql = undefined;

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var neo4jgraphql = exports.neo4jgraphql = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(object, params, context, resolveInfo) {
    var debug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var query, session, result;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            query = void 0;

            if ((0, _utils.isMutation)(resolveInfo)) {
              query = cypherMutation(params, context, resolveInfo);
              if ((0, _utils.isAddRelationshipMutation)(resolveInfo)) {
                //params = fixParamsForAddRelationshipMutation(params, resolveInfo);
              } else {
                params = { params: params };
              }
            } else {
              query = cypherQuery(params, context, resolveInfo);
            }

            if (debug) {
              console.log(query);
              console.log(params);
            }

            session = context.driver.session();
            _context.next = 6;
            return session.run(query, params);

          case 6:
            result = _context.sent;
            return _context.abrupt('return', (0, _utils.extractQueryResult)(result, resolveInfo.returnType));

          case 8:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function neo4jgraphql(_x2, _x3, _x4, _x5) {
    return _ref.apply(this, arguments);
  };
}();

exports.cypherQuery = cypherQuery;
exports.cypherMutation = cypherMutation;
exports.augmentSchema = augmentSchema;

var _filter = require('lodash/filter');

var _filter2 = _interopRequireDefault(_filter);

var _utils = require('./utils');

var _selections = require('./selections');

var _augmentSchema = require('./augmentSchema');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function cypherQuery(_ref2, context, resolveInfo) {
  var _ref2$first = _ref2.first,
      first = _ref2$first === undefined ? -1 : _ref2$first,
      _ref2$offset = _ref2.offset,
      offset = _ref2$offset === undefined ? 0 : _ref2$offset,
      _id = _ref2._id,
      otherParams = (0, _objectWithoutProperties3.default)(_ref2, ['first', 'offset', '_id']);

  var _typeIdentifiers = (0, _utils.typeIdentifiers)(resolveInfo.returnType),
      typeName = _typeIdentifiers.typeName,
      variableName = _typeIdentifiers.variableName;

  var schemaType = resolveInfo.schema.getType(typeName);

  var filteredFieldNodes = (0, _filter2.default)(resolveInfo.fieldNodes, function (n) {
    return n.name.value === resolveInfo.fieldName;
  });

  // FIXME: how to handle multiple fieldNode matches
  var selections = (0, _utils.extractSelections)(filteredFieldNodes[0].selectionSet.selections, resolveInfo.fragments);

  // FIXME: support IN for multiple values -> WHERE
  var argString = (0, _stringify2.default)(otherParams).replace(/\"([^(\")"]+)\":/g, '$1:');

  var idWherePredicate = typeof _id !== 'undefined' ? 'WHERE ID(' + variableName + ')=' + _id + ' ' : '';
  var outerSkipLimit = 'SKIP ' + offset + (first > -1 ? ' LIMIT ' + first : '');

  var query = void 0;

  //TODO: wrap in try catch
  var queryTypeCypherDirective = resolveInfo.schema.getQueryType().getFields()[resolveInfo.fieldName].astNode.directives.filter(function (x) {
    return x.name.value === 'cypher';
  })[0];

  if (queryTypeCypherDirective) {
    // QueryType with a @cypher directive
    var cypherQueryArg = queryTypeCypherDirective.arguments.filter(function (x) {
      return x.name.value === 'statement';
    })[0];

    query = 'WITH apoc.cypher.runFirstColumn("' + cypherQueryArg.value.value + '", ' + argString + ', True) AS x UNWIND x AS ' + variableName + '\n    RETURN ' + variableName + ' {' + (0, _selections.buildCypherSelection)({
      initial: '',
      selections: selections,
      variableName: variableName,
      schemaType: schemaType,
      resolveInfo: resolveInfo
    }) + '} AS ' + variableName + ' ' + outerSkipLimit;
  } else {
    // No @cypher directive on QueryType
    query = 'MATCH (' + variableName + ':' + typeName + ' ' + argString + ') ' + idWherePredicate + (
    // ${variableName} { ${selection} } as ${variableName}`;
    'RETURN ' + variableName + ' {' + (0, _selections.buildCypherSelection)({
      initial: '',
      selections: selections,
      variableName: variableName,
      schemaType: schemaType,
      resolveInfo: resolveInfo
    }) + '} AS ' + variableName + ' ' + outerSkipLimit);
  }

  return query;
}

function cypherMutation(_ref3, context, resolveInfo) {
  var _ref3$first = _ref3.first,
      first = _ref3$first === undefined ? -1 : _ref3$first,
      _ref3$offset = _ref3.offset,
      offset = _ref3$offset === undefined ? 0 : _ref3$offset,
      _id = _ref3._id,
      otherParams = (0, _objectWithoutProperties3.default)(_ref3, ['first', 'offset', '_id']);

  // FIXME: lots of duplication here with cypherQuery, extract into util module

  var _typeIdentifiers2 = (0, _utils.typeIdentifiers)(resolveInfo.returnType),
      typeName = _typeIdentifiers2.typeName,
      variableName = _typeIdentifiers2.variableName;

  var schemaType = resolveInfo.schema.getType(typeName);

  var filteredFieldNodes = (0, _filter2.default)(resolveInfo.fieldNodes, function (n) {
    return n.name.value === resolveInfo.fieldName;
  });

  // FIXME: how to handle multiple fieldNode matches
  var selections = (0, _utils.extractSelections)(filteredFieldNodes[0].selectionSet.selections, resolveInfo.fragments);

  if (selections.length === 0) {
    // FIXME: why aren't the selections found in the filteredFieldNode?
    selections = (0, _utils.extractSelections)(resolveInfo.operation.selectionSet.selections, resolveInfo.fragments);
  }

  // FIXME: support IN for multiple values -> WHERE
  var argString = (0, _stringify2.default)(otherParams).replace(/\"([^(\")"]+)\":/g, '$1:');

  var idWherePredicate = typeof _id !== 'undefined' ? 'WHERE ID(' + variableName + ')=' + _id + ' ' : '';
  var outerSkipLimit = 'SKIP ' + offset + (first > -1 ? ' LIMIT ' + first : '');

  var query = void 0;
  var mutationTypeCypherDirective = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.directives.filter(function (x) {
    return x.name.value === 'cypher';
  })[0];

  if (mutationTypeCypherDirective) {
    var cypherQueryArg = mutationTypeCypherDirective.arguments.filter(function (x) {
      return x.name.value === 'statement';
    })[0];

    query = 'CALL apoc.cypher.doIt("' + cypherQueryArg.value.value + '", ' + argString + ') YIELD value\n    WITH apoc.map.values(value, [keys(value)[0]])[0] AS ' + variableName + '\n    RETURN ' + variableName + ' {' + (0, _selections.buildCypherSelection)({
      initial: '',
      selections: selections,
      variableName: variableName,
      schemaType: schemaType,
      resolveInfo: resolveInfo
    }) + '} AS ' + variableName + ' ' + outerSkipLimit;
  } else if (resolveInfo.fieldName.startsWith('Create') || resolveInfo.fieldName.startsWith('create')) {
    // CREATE node
    // TODO: handle for create relationship
    // TODO: update / delete
    // TODO: augment schema
    query = 'CREATE (' + variableName + ':' + typeName + ') ';
    query += 'SET ' + variableName + ' = $params ';
    //query += `RETURN ${variable}`;
    query += 'RETURN ' + variableName + ' {' + (0, _selections.buildCypherSelection)({
      initial: '',
      selections: selections,
      variableName: variableName,
      schemaType: schemaType,
      resolveInfo: resolveInfo
    });
    query += '} AS ' + variableName;
  } else if (resolveInfo.fieldName.startsWith('Add') || resolveInfo.fieldName.startsWith('add')) {
    var mutationMeta = void 0,
        relationshipNameArg = void 0,
        fromTypeArg = void 0,
        toTypeArg = void 0;

    try {
      mutationMeta = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.directives.filter(function (x) {
        return x.name.value === 'MutationMeta';
      })[0];
    } catch (e) {
      throw new Error('Missing required MutationMeta directive on add relationship directive');
    }

    try {
      relationshipNameArg = mutationMeta.arguments.filter(function (x) {
        return x.name.value === 'relationship';
      })[0];

      fromTypeArg = mutationMeta.arguments.filter(function (x) {
        return x.name.value === 'from';
      })[0];

      toTypeArg = mutationMeta.arguments.filter(function (x) {
        return x.name.value === 'to';
      })[0];
    } catch (e) {
      throw new Error('Missing required argument in MutationMeta directive (relationship, from, or to)');
    }
    //TODO: need to handle one-to-one and one-to-many

    var fromType = fromTypeArg.value.value,
        toType = toTypeArg.value.value,
        fromVar = (0, _utils.lowFirstLetter)(fromType),
        toVar = (0, _utils.lowFirstLetter)(toType),
        relationshipName = relationshipNameArg.value.value,
        fromParam = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.arguments[0].name.value.substr(fromVar.length),
        toParam = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.arguments[1].name.value.substr(toVar.length);

    var _query = 'MATCH (' + fromVar + ':' + fromType + ' {' + fromParam + ': $' + resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.arguments[0].name.value + '})\n       MATCH (' + toVar + ':' + toType + ' {' + toParam + ': $' + resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.arguments[1].name.value + '})\n      CREATE (' + fromVar + ')-[:' + relationshipName + ']->(' + toVar + ')\n      RETURN ' + fromVar + ' {' + (0, _selections.buildCypherSelection)({
      initial: '',
      selections: selections,
      variableName: variableName,
      schemaType: schemaType,
      resolveInfo: resolveInfo
    }) + '} AS ' + fromVar + ';';

    return _query;
  } else {
    // throw error - don't know how to handle this type of mutation
    throw new Error('Mutation does not follow naming convention.');
  }
  return query;
}

function augmentSchema(schema) {
  var mutationSchema = (0, _augmentSchema.addMutationsToSchema)(schema);

  return mutationSchema;
}
//# sourceMappingURL=index.js.map